# MQ入门

## 同步通讯和异步通讯

同步通讯：需要实时响应

异步通讯：不需要马上响应

两种方式各有优劣，同步通讯可以立即得到响应，但是你却不能跟服务同时通讯。异步通讯可以同时与多服务通讯，但是往往响应会有延迟。

### 同步通讯

Feign的调用就是属于同步通讯

弊端：

- 耦合度高：每次加入新的需求，都要修改原来的代码
- 性能下降：调用者需要等待服务提供者响应，如果调用链过长则响应时间等于每次调用的时间之和。
- 资源浪费：调用链中的每个服务在等待响应过程中，不能释放请求占用的资源，高并发场景下会极度浪费系统资源
- 级联失败：如果服务提供者出现问题，所有调用方都会跟着出问题，如同多米诺骨牌一样，迅速导致整个微服务群故障

优势：

- 时效性较强，可以立即得到结果

### 异步通讯

为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个中间人（Broker）。发布者发布事件到Broker，不关心谁来订阅事件。订阅者从Broker订阅事件，不关心谁发来的消息。

![image-20220211151425693](https://github.com/BlackMe2327/cloudimages27/blob/main/img/image-20220211151425693.png?raw=true)

弊端：

- 架构复杂了，业务没有明显的流程线，不好管理
- 需要依赖于Broker的可靠、安全、性能

优势：

- 吞吐量提升：无需等待订阅者处理完成，响应更快速

- 故障隔离：服务没有直接调用，不存在级联失败问题
- 调用间没有阻塞，不会造成无效的资源占用
- 耦合度极低，每个服务都可以灵活插拔，可替换
- 流量削峰：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件

## MQ技术对比

`MQ`，中文是消息队列（`MessageQueue`），字面来看就是存放消息的队列。也就是事件驱动架构中的Broker。

|            | **`RabbitMQ`**          | **`ActiveMQ`**                 | **`RocketMQ`** | **`Kafka`** |
| ---------- | ----------------------- | ------------------------------ | -------------- | ----------- |
| 公司/社区  | Rabbit                  | Apache                         | 阿里           | Apache      |
| 开发语言   | Erlang                  | Java                           | Java           | Scala&Java  |
| 协议支持   | AMQP，XMPP，SMTP，STOMP | OpenWire,STOMP，REST,XMPP,AMQP | 自定义协议     | 自定义协议  |
| 可用性     | 高                      | 一般                           | 高             | 高          |
| 单机吞吐量 | 一般                    | 差                             | 高             | 非常高      |
| 消息延迟   | 微秒级                  | 毫秒级                         | 毫秒级         | 毫秒以内    |
| 消息可靠性 | 高                      | 一般                           | 高             | 一般        |

追求可用性：`Kafka`、 `RocketMQ` 、`RabbitMQ`

追求可靠性：`RabbitMQ`、`RocketMQ`

追求吞吐能力：`RocketMQ`、`Kafka`

追求消息低延迟：`RabbitMQ`、`Kafka`