# Java类和对象

## 面向对象和面向过程的区别

- 面向过程：面向过程比面向对象的性能高。因为类调用是需要实例化，开销比较大、比较消耗资源、所以当性能是最重要的考量因素时一般采用面向过程开发。但是，面向过程没有面向对象易维护、易复用、易扩展
- 面向对象：面向对象易维护、易复用、易扩展。因为面向对象有封装、继承、多态性的特性，所以设计出低耦合的系统、是系统更加灵活、更加易于维护。但是，面向对象性能比面向过程低

> 面向过程也需要分配内存，计算内存偏移量，Java性能差的主要原因并不是因为他是面向对象语言，而是JAVA是半编译语言，最终执行代码并不是可以直接被CPU执行的二进制机械码。
>
> 而面向过程语言大多是直接编译成机械码在电脑上执行，并且其他一些面向过程的脚本语言性能也并不一定比Java好。

## 构造器Constructor是否可以被override？

Constructor不能被override，但是可以overload，所以你可以看到一个类中有多个构造函数的情况。

## Java中定义一个空构造方法的作用

Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决方法是在父类中加上一个空构造方法。

## 成员变量和局部变量的区别

1. 语法：成员变量属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被public,private,static等修饰符所修饰，而局部变量不能被访问控制修饰符及static所修饰；但是，成员变量和局部变量杜能被final所修饰。
2. 存储方式：如果成员变量使用static修饰，那么这个成员变量是属于类的，如果没有static修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。
3. 变量在内存中的生存时间：成员变量是对象的一部分，他随着独爱你给的创建而存在，而局部变量随着方法的调用而自动消失。
4. 成员变量如果没有被赋初值：则会自动以类型的默认值而赋值（被final修饰的成员变量必须显式的赋值），而局部变量则不会自动赋值。

## 类的构造方法的作用

​		类的构造方法作用是完成对类对象的初始化工作。若一个类没有构造方法也可以执行，因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法，Java就不会再添加默认的无参数的构造方法，这个时候就不能直接new一个对象而不传递参数了，所以我们一直在不知不觉中使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参构造方法）。如果我们重载了有残的构造方法，记得都要把无参的构造方法写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。

## 构造方法的特性

1. 名字与类名相同
2. 没有返回值但是不能用void声明构造函数
3. 生成类的对象是自动执行，无序调用

## 对象相等和指向他们的引用相等两者的不同

对象的相等比的是内存中存放的内容是否相等。

引用相等比的是他们指向的内存地址是否相等。

# Java面向对象三大特征

## 封装

​		封装是指将一个对象的状态信息（属性）隐藏在对象内部，不允许外部对象直接访问对象内部信息。但是可以提供一些可以被外界访问的方法来操作属性。如果属性不想背外界访问，我们可以不提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类本身没有了意义。

## 继承

​		不同类型的对象，相互之间经常有一定数量的共同点。同时，每一个对象还定义了额外的特性使得他们与众不同。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性的继承父类。通过使用继承，可以快速的创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间，提高我们的开发效率。

1. 子类拥有父类对象的所有属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问的（只是拥有）
2. 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展
3. 子类可以用自己的方式实现父类方法

## 多态

​		表示一个对象有多种状态。具体表现为父类的引用指向子类的实例。

1. 对象类型和引用类型之间具有继承（类）/实现（接口）的关系
2. 对象类型不可变、引用类型可变
3. 方法具有多态性，属性不具有多态性
4. 引用类型变量发出的方法调用的到底是那个类的方法，必须在程序运行期间才能确定
5. 多态不能调用“只在子类中存在但在父类中不存在”的方法
6. 如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类方法，执行的是父类方法

# 修饰符

## 在一个静态方法中调用一个非静态方法为什么是非法的？

​		由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。

## 静态方法和实例方法有何不同

1. 在外部调用静态方法时，可以使用“类名.方法名”的方式、也可以使用“对象名.方法名”的方式。而实例方法只有后面这种方式，也就是说调用静态方法可以无需创建对象。
2. 静态方法在访问本类的成员时，只允许访问静态成员，不允许访问实例成员变量和实例方法；实例方法则无此限制。

## 常见关键字总结:static,final,this,super

### static关键字

1. 使用static可以修饰成员变量，常量，方法和代码块
2. 静态成员是全局的，归整个类所有，不依赖特定的对象，是被所有类的对象所共享的
3. 只要类被java虚拟机加载，就可以根据类名在全局数据域内找到他们

### this关键字

this方法总是指向调用该方法的对象

> this可以代表任何对象，当this出现在某个方法体中时，他所代表的对象是不确定的，但他的类型是确定的，它所代表的只能是当前类的实例。

### super关键字

1. 可以用来调用直接父类中的属性，方法，构造方法
2. 想要在子类中使用父类的属性时，就要用super.属性名
3. 构造方法不能被继承，但子类可以通过super调用父类的构造方法
4. 构造方法可以被重载，一个类里面可以有多个构造方法

### final关键字

1. final修饰类，不存在子类，比如String类
2. final修饰方法，子类不能重写
3. final修饰属性，为常量，需要初始化，并且不可修改，常量命名通常用大写字母，每个字母中间用下划线隔开
4. final进行修饰属性，子类可以使用

# 接口和抽象类

## 接口和抽象类的区别

1. 接口的默认方法时public，所有方法在接口中不能有实现（Java8开始接口方法可以有默认实现），而抽象类可以有非抽象方法
2. 接口中除了static、final变量，不能有其他变量，而抽象类中则不一定
3. 一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口
4. 接口方法默认修饰符是public,抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写所以不能用private关键字修饰）
5. 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范

> 备注：在jdk8中，接口也可以定义静态方法，可以直接用接口名调用。实现类是不可以调用的。如果同时实现了两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。

