# Java内存区域（运行时数据区）

**JDK1.8之前：**

![image-20220307172658491](https://github.com/BlackMe2327/cloudimages27/blob/main/img/image-20220307172658491.png?raw=true)

**JDK1.8之后：**

![image-20220307172953794](https://github.com/BlackMe2327/cloudimages27/blob/main/img/image-20220307172953794.png?raw=true)

**线程私有的：**

- 程序计数器
- 虚拟机栈
- 本地方法栈

**线程共享的：**

- 堆
- 方法区
- 直接内存（非运行时数据区的一部分）

## 程序计数器（线程私有）

​		程序计数器是一块较小的内存空间，可以看做是当前线程锁执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。

​		为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。

**注意：**程序计数器是唯一一个不会出现OOM的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。

## Java虚拟机栈（线程私有）

​		与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是Java方法执行的内存模型，每次方法调用的数据都是通过栈传递的。

​		Java内存可以粗糙的区分为堆内存（Heap）和栈内存（Stack），其中栈就是现在说的虚拟机栈，或者说是虚拟机中局部变量表的部分。

​		局部变量栈表主要存放了编译期可知的各种数据模型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）

**Java虚拟机栈会出现两种错误：**

- **StackOverFlowError：**若Java虚拟机栈的内存大小不允许动态扩展，那么线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError错误
- **OutOfMemoryError：**若Java虚拟机堆中没有空闲内存，并且垃圾回收器也无法提供更多内存的话。就会抛出OutOfMemoryError错误

java虚拟机栈是线程私有的，每个线程都有各自的java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡

## 本地方法栈（线程私有）

​		虚拟机栈为虚拟机执行java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native服务。在HotSpot虚拟机中和java虚拟机栈合二为一。

​		本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。

​		方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现StackOverFlowError和OutOfMemoryError两种错误。

## 堆（线程共享）

​		堆是java虚拟机所管理的内存中最大的一块，java堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。

​		java堆是垃圾收集器管理的主要区域，因此也被称作GC堆。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以java堆可以细分为：新生代和老生代：再细致一点儿有：Eden空间、From Survivor、To Survivor空间等。进一步划分的目的是更好地回收内存，或者更快地分配内存。

​		堆这里比较容易出现的错误是OOM错误，并且这种错误的表现形式有几种：

1. OutOfMemoryError：GC Overhead Limit Exceeded：当jvm花费太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误
2. java.lang.OutOfMemoryError：java heap space：假如在创建新对象时，堆内存中的空间不足以存放新创建的对象，就会引发java.lang.OutOfMemoryError：java heap space错误。
3. ......

## 方法区（线程共享）

​		方法区与java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是他却有一个别名叫做Non-Heap(非堆)，目的应该是与java堆区分开来。

## 直接内存（方法共享）

​		直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁使用，而且也可能导致OOM错误出现。

​		本机直接内存的分配不会受到Java堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。

# JAVA对象的创建过程

1. **类加载检查：**虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已经被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

2. **分配内存：**在类加载检查过后，接下来虚拟机将为新生对象分配内存。都像所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从java堆中划分出来。分配方式有“指针碰撞”和“空闲列表”两种，选择那种分配方式由java堆是否规整决定，而java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。

   1. **内存分配的两种方式：**

      1. **指针碰撞**
         - 适用场合：堆内存规整的情况下
         - 原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可
         - GC收集器：Serial、ParNew
      2. **空闲列表**
         - 适用场合：堆内存不规整的情况
         - 原理：虚拟机会维护一个列表，该列表中会记录那些内存块是可用的，在分配的时候，找一块足够大的内存块儿来划分给对象实例，最后更新列表记录
         - GC收集器：CMS

   2. **内存分配并发问题：**

      ​		在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是频繁的事情，作为虚拟机来说，必须保证线程是安全的，通常来将，虚拟机采用两种方式来保证线程安全：

      - **CAS+失败者重试：**CAS是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。
      - **TLAB：**为每一个线程预先在Eden区分配一块儿内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已经耗尽时，在采用上述的CAS进行内存分配。

2. **初始化零值：**内存分配完成后，虚拟机需要将分配到内存空间的初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

4. **设置对象头：**初始化零值完成后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象头中。另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

5. **执行init方法：**在上面工作都完成后，从虚拟机的角度来看，一个新的对象已经产生了，但从jaa程序的视角来看，对象创建才刚开始，init方法还没有执行，所有字段都还为零。所以一般来说，执行new指令之后会接着执行init方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

#    对象访问定位的两种方式

​		建立对象是为了使用对象，java程序通过栈上的reference数据来操作对上的具体对象。对象的访问方式有虚拟机实现而定，目前的主流的访问方式有使用句柄和直接指针两种：

1. **句柄：**   如果使用句柄的话，那么java堆中会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据格子的具体地址信息；
2. **直接指针：**如果使用直接指针访问，那么java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象的地址。

# 堆内存中对象的分配的基本策略

1. 对象优先在eden区分配
2. 大对象直接进入老年代
3. 长期存活的对象将进入老年代

## 对象优先在eden区分配

​		目前主流的垃圾收集器都会采用分代回收的算法，因此需要将堆内存分为新生代和老生代，这样我们就可以根据各个年代的特点选择适合的垃圾收集算法。

​		大多数情况下，对象在新生代中eden区分配。当eden区没有足够空间进行分配时，虚拟机将发起一次Minor.GC

## 大对象直接进入老年代

大对象就是需要大量连续内存空间的对象。

为了避免为大对象分配内存时由于分配担保机制带来的赋值而降低效率。      

## 长期存活的对象将进入老年代

​		虚拟机采用了 分代收集的思想来管理内存，那么内存回收时就必须能识别那些对象应放在新生代，那些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄计数器。

​		如果对象在Eden出生并经过第一次Minor.GC后仍然能够存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。对象在Survivor中每熬过一次Minor.GC，年龄就增加一岁，当他的年龄增加到一定程度（默认十五岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数`-XX:MaxTenuringThreshold`来设置。

# 如何匹配判断对象是否死亡？

## 引用计数法

给对象添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。

## 可达性分析算法

这个算法的基本思想就是通过一系列的称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连的话，则证明此对象是不可用的。

# 强引用、软引用、弱引用、虚引用

## 强引用

大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，java虚拟机宁愿抛出OOM错误，使程序异常终止，也不会随意回收具有强引用的对象来解决内存不足问题。

## 软引用

如果一个对象只具有软引用，那就类似于可有可无的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的告诉缓存。

## 弱引用

如果一个对象只具有弱引用作用，那就类似于可有可无的生活用品。弱引用和软引用的区别在于：值具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快法系那些只具有弱引用的对象。

​		弱引用可以和一个引用队列联合使用，如果弱引用所引用的对象被垃圾回收，java虚拟机会把这个弱引用加入到与之关联的引用队列中。

## 虚引用

​		虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在热河时候都可能被垃圾回收。**虚引用主要用来跟踪对象被垃圾回收的活动。**

**虚引用与软引用和弱引用的一个区别在于：**虚引用必须和引用队列联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

​		特别注意，在程序设计中一般很少使用弱引用和虚引用，使用软引用的情况较多，这是因为软引用可以加速jvm对垃圾内存的回收速度，可以维护系统的运行安全，防止内存移除等问题的产生。

# 如何判断一个常量是废弃常量

运行时常量池主要回收的是废弃的常量。

加入常量池中存在字符串“abc”，如果当前没有任何String对象引用该字符串常量的话，就说明常量"abc"就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc"就会被系统清理出常量池。

# 如何判断一个类是无用类

判定一个类是否是"无用的类"的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是“无用的类”

- 该类所有实例都已经被回收，也就是java堆中不存在该类的任何实例
- 加载该类ClassLoader已经被回收
- 该类的对应的java.lang.Class对象没有在任何地方被引用，无法在热河地方通过反射访问该类的方法

虚拟机可以对满足以上3个条件的无用类进行回收，这里仅仅说可以，而并不是和对象一样不使用了就会必然必然回收。

# 垃圾收集的算法

## 标记-清除算法

该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。他是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：

1. 效率问题
2. 空间问题（标记清楚后悔产生大量不连续的碎片）

![image-20220309145528178](https://github.com/BlackMe2327/cloudimages27/blob/main/img/image-20220309145528178.png?raw=true)

## 复制算法

为了解决效率问题，“复制”收集算法出现了。他可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完之后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存空间的一般进行回收。

![image-20220309145729626](https://github.com/BlackMe2327/cloudimages27/blob/main/img/image-20220309145729626.png?raw=true)

​      

## 标记-整理算法

根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后序步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。

## 分代收集算法

当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。

比如在新生代中，每次手机都会有大量的对象死去，所以可以选择复制算法，只需要付出少量对象的赋值成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对他进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集





















